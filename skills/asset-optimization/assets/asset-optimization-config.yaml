# Asset Optimization Configuration
# Image, font, and media optimization patterns

image_formats:
  comparison:
    jpeg:
      pros: "Universal support, good for photos"
      cons: "No transparency, lossy only"
      use_for: "Photos without transparency"

    png:
      pros: "Lossless, transparency support"
      cons: "Large file sizes"
      use_for: "Graphics with transparency, screenshots"

    webp:
      pros: "25-35% smaller than JPEG, transparency, animation"
      cons: "Older browser support (Safari < 14)"
      use_for: "Most web images"

    avif:
      pros: "50% smaller than JPEG, best compression"
      cons: "Limited browser support, slow encoding"
      use_for: "High-quality images when supported"

    svg:
      pros: "Scalable, tiny for simple graphics"
      cons: "Not for photos, complex SVGs can be large"
      use_for: "Icons, logos, simple illustrations"

  format_selection: |
    Decision tree:
    1. Simple icon/logo? → SVG
    2. Animation needed? → WebP or GIF (small)
    3. Photo quality priority? → AVIF with WebP fallback
    4. Transparency needed? → WebP or PNG fallback
    5. Universal support required? → JPEG with WebP preferred

responsive_images:
  srcset_syntax: |
    <!-- Width descriptors -->
    <img
      src="image-800.jpg"
      srcset="
        image-400.jpg 400w,
        image-800.jpg 800w,
        image-1200.jpg 1200w
      "
      sizes="(max-width: 600px) 100vw, 50vw"
      alt="Description"
      width="800"
      height="600"
    />

    <!-- Pixel density descriptors -->
    <img
      src="image-1x.jpg"
      srcset="
        image-1x.jpg 1x,
        image-2x.jpg 2x,
        image-3x.jpg 3x
      "
      alt="Description"
    />

  picture_element: |
    <picture>
      <!-- AVIF for supporting browsers -->
      <source
        type="image/avif"
        srcset="image.avif"
      />
      <!-- WebP fallback -->
      <source
        type="image/webp"
        srcset="image.webp"
      />
      <!-- JPEG fallback -->
      <img
        src="image.jpg"
        alt="Description"
        width="800"
        height="600"
      />
    </picture>

  art_direction: |
    <picture>
      <!-- Different crop for mobile -->
      <source
        media="(max-width: 600px)"
        srcset="image-mobile.jpg"
      />
      <!-- Different crop for tablet -->
      <source
        media="(max-width: 1024px)"
        srcset="image-tablet.jpg"
      />
      <!-- Default desktop image -->
      <img src="image-desktop.jpg" alt="Description" />
    </picture>

lazy_loading:
  native: |
    <!-- Native lazy loading -->
    <img
      src="image.jpg"
      loading="lazy"
      alt="Description"
      width="800"
      height="600"
    />

    <!-- Eager loading for above-fold -->
    <img
      src="hero.jpg"
      loading="eager"
      fetchpriority="high"
      alt="Hero image"
    />

  intersection_observer: |
    // Custom lazy loading with blur-up
    const lazyImages = document.querySelectorAll('img[data-src]');

    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          img.onload = () => img.classList.add('loaded');
          imageObserver.unobserve(img);
        }
      });
    }, {
      rootMargin: '50px 0px',
      threshold: 0.01
    });

    lazyImages.forEach(img => imageObserver.observe(img));

  framework_specific:
    react: |
      // Using react-lazy-load-image-component
      import { LazyLoadImage } from 'react-lazy-load-image-component';

      <LazyLoadImage
        src="image.jpg"
        alt="Description"
        effect="blur"
        placeholderSrc="tiny-placeholder.jpg"
      />

    nextjs: |
      import Image from 'next/image';

      <Image
        src="/image.jpg"
        alt="Description"
        width={800}
        height={600}
        placeholder="blur"
        blurDataURL="data:image/..."
      />

image_compression:
  tools:
    cli:
      - "imagemin"
      - "sharp"
      - "squoosh-cli"

    online:
      - "TinyPNG"
      - "Squoosh.app"
      - "SVGOMG"

  webpack_config: |
    // Using image-minimizer-webpack-plugin
    const ImageMinimizerPlugin = require('image-minimizer-webpack-plugin');

    module.exports = {
      optimization: {
        minimizer: [
          new ImageMinimizerPlugin({
            minimizer: {
              implementation: ImageMinimizerPlugin.sharpMinify,
              options: {
                encodeOptions: {
                  jpeg: { quality: 80 },
                  webp: { quality: 80 },
                  avif: { quality: 65 },
                  png: { compressionLevel: 9 },
                },
              },
            },
            generator: [
              {
                preset: 'webp',
                implementation: ImageMinimizerPlugin.sharpGenerate,
                options: {
                  encodeOptions: { webp: { quality: 80 } },
                },
              },
            ],
          }),
        ],
      },
    };

  vite_config: |
    // Using vite-plugin-image-optimizer
    import { ViteImageOptimizer } from 'vite-plugin-image-optimizer';

    export default {
      plugins: [
        ViteImageOptimizer({
          jpeg: { quality: 80 },
          jpg: { quality: 80 },
          png: { quality: 80 },
          webp: { quality: 80 },
          avif: { quality: 65 },
        }),
      ],
    };

font_optimization:
  font_display: |
    @font-face {
      font-family: 'Custom Font';
      src: url('font.woff2') format('woff2');
      font-display: swap;  /* Show fallback, swap when loaded */
    }

    /* Options:
      auto: Browser default
      block: Short block period, infinite swap
      swap: Very short block, infinite swap (recommended)
      fallback: Short block, short swap
      optional: Very short block, no swap (for optional fonts)
    */

  subsetting: |
    # Using pyftsubset
    pyftsubset font.ttf \
      --output-file=font-subset.woff2 \
      --flavor=woff2 \
      --layout-features='*' \
      --unicodes="U+0000-00FF"  # Basic Latin

  preloading: |
    <link
      rel="preload"
      href="/fonts/custom-font.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />

  variable_fonts: |
    @font-face {
      font-family: 'Variable Font';
      src: url('font-variable.woff2') format('woff2-variations');
      font-weight: 100 900;
      font-style: normal;
    }

    /* Use weight ranges instead of multiple files */
    .light { font-weight: 300; }
    .regular { font-weight: 400; }
    .bold { font-weight: 700; }

cdn_strategies:
  image_cdns:
    - name: "Cloudinary"
      transformation: "https://res.cloudinary.com/demo/image/upload/w_400,f_auto,q_auto/sample.jpg"

    - name: "imgix"
      transformation: "https://example.imgix.net/image.jpg?w=400&auto=format,compress"

    - name: "Cloudflare Images"
      transformation: "https://imagedelivery.net/<hash>/<image_id>/w=400"

  benefits:
    - "Automatic format conversion"
    - "On-the-fly resizing"
    - "Global edge caching"
    - "Quality optimization"
    - "Bandwidth savings"

  implementation: |
    // Dynamic image URL generation
    function getOptimizedImageUrl(src, width, format = 'auto') {
      const baseUrl = 'https://res.cloudinary.com/your-cloud/image/upload';
      return `${baseUrl}/w_${width},f_${format},q_auto/${src}`;
    }

svg_optimization:
  svgo_config: |
    // svgo.config.js
    module.exports = {
      plugins: [
        'preset-default',
        'removeDimensions',
        {
          name: 'removeAttrs',
          params: { attrs: '(stroke|fill)' }
        }
      ]
    };

  inline_vs_external: |
    Inline SVG:
    + Can be styled with CSS
    + No additional HTTP request
    - Increases HTML size
    - Not cached separately

    External SVG:
    + Cached by browser
    + Cleaner HTML
    - Additional request
    - Styling limitations

best_practices:
  - "Always specify width and height"
  - "Use WebP with JPEG/PNG fallback"
  - "Lazy load below-fold images"
  - "Preload hero images"
  - "Use responsive images with srcset"
  - "Compress all images"
  - "Use font-display: swap"
  - "Subset fonts when possible"
  - "Consider image CDNs for scale"
