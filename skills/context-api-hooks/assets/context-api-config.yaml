# React Context API Patterns
# Built-in state management with Context

basic_context:
  creation: |
    import { createContext, useContext, useState, ReactNode } from 'react';

    // 1. Define types
    interface ThemeContextType {
      theme: 'light' | 'dark';
      toggleTheme: () => void;
    }

    // 2. Create context with default value
    const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

    // 3. Create provider component
    interface ThemeProviderProps {
      children: ReactNode;
    }

    export function ThemeProvider({ children }: ThemeProviderProps) {
      const [theme, setTheme] = useState<'light' | 'dark'>('light');

      const toggleTheme = () => {
        setTheme(prev => prev === 'light' ? 'dark' : 'light');
      };

      return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
          {children}
        </ThemeContext.Provider>
      );
    }

    // 4. Create custom hook
    export function useTheme() {
      const context = useContext(ThemeContext);
      if (context === undefined) {
        throw new Error('useTheme must be used within a ThemeProvider');
      }
      return context;
    }

  usage: |
    // App.tsx
    function App() {
      return (
        <ThemeProvider>
          <MainContent />
        </ThemeProvider>
      );
    }

    // Any child component
    function ThemeToggle() {
      const { theme, toggleTheme } = useTheme();

      return (
        <button onClick={toggleTheme}>
          Current: {theme}
        </button>
      );
    }

context_with_reducer:
  pattern: |
    import { createContext, useContext, useReducer, ReactNode } from 'react';

    // Types
    interface State {
      count: number;
      user: User | null;
    }

    type Action =
      | { type: 'INCREMENT' }
      | { type: 'DECREMENT' }
      | { type: 'SET_USER'; payload: User }
      | { type: 'LOGOUT' };

    interface AppContextType {
      state: State;
      dispatch: React.Dispatch<Action>;
    }

    // Reducer
    function reducer(state: State, action: Action): State {
      switch (action.type) {
        case 'INCREMENT':
          return { ...state, count: state.count + 1 };
        case 'DECREMENT':
          return { ...state, count: state.count - 1 };
        case 'SET_USER':
          return { ...state, user: action.payload };
        case 'LOGOUT':
          return { ...state, user: null };
        default:
          return state;
      }
    }

    // Context
    const AppContext = createContext<AppContextType | undefined>(undefined);

    // Provider
    const initialState: State = { count: 0, user: null };

    export function AppProvider({ children }: { children: ReactNode }) {
      const [state, dispatch] = useReducer(reducer, initialState);

      return (
        <AppContext.Provider value={{ state, dispatch }}>
          {children}
        </AppContext.Provider>
      );
    }

    // Hook
    export function useApp() {
      const context = useContext(AppContext);
      if (!context) {
        throw new Error('useApp must be used within AppProvider');
      }
      return context;
    }

    // Action helpers
    export function useAppActions() {
      const { dispatch } = useApp();

      return {
        increment: () => dispatch({ type: 'INCREMENT' }),
        decrement: () => dispatch({ type: 'DECREMENT' }),
        setUser: (user: User) => dispatch({ type: 'SET_USER', payload: user }),
        logout: () => dispatch({ type: 'LOGOUT' }),
      };
    }

multiple_contexts:
  separate_concerns: |
    // Separate contexts for different concerns
    import { AuthProvider, useAuth } from './contexts/AuthContext';
    import { ThemeProvider, useTheme } from './contexts/ThemeContext';
    import { CartProvider, useCart } from './contexts/CartContext';

    function App() {
      return (
        <AuthProvider>
          <ThemeProvider>
            <CartProvider>
              <MainContent />
            </CartProvider>
          </ThemeProvider>
        </AuthProvider>
      );
    }

  compose_providers: |
    // Provider composition utility
    interface ProviderProps {
      children: ReactNode;
    }

    type Provider = React.ComponentType<ProviderProps>;

    function composeProviders(...providers: Provider[]) {
      return function ComposedProviders({ children }: ProviderProps) {
        return providers.reduceRight(
          (acc, Provider) => <Provider>{acc}</Provider>,
          children
        );
      };
    }

    const AppProviders = composeProviders(
      AuthProvider,
      ThemeProvider,
      CartProvider
    );

    function App() {
      return (
        <AppProviders>
          <MainContent />
        </AppProviders>
      );
    }

performance_optimization:
  split_contexts: |
    // ❌ One context for everything = many re-renders
    const AppContext = createContext({ user, theme, cart, dispatch });

    // ✅ Split into separate contexts
    const UserContext = createContext(user);
    const ThemeContext = createContext(theme);
    const CartContext = createContext(cart);

  memoize_value: |
    function AppProvider({ children }: { children: ReactNode }) {
      const [state, dispatch] = useReducer(reducer, initialState);

      // ✅ Memoize context value to prevent unnecessary re-renders
      const value = useMemo(
        () => ({ state, dispatch }),
        [state]  // Only recreate when state changes
      );

      return (
        <AppContext.Provider value={value}>
          {children}
        </AppContext.Provider>
      );
    }

  separate_state_dispatch: |
    // Split state and dispatch into separate contexts
    const StateContext = createContext<State | undefined>(undefined);
    const DispatchContext = createContext<Dispatch<Action> | undefined>(undefined);

    function AppProvider({ children }: { children: ReactNode }) {
      const [state, dispatch] = useReducer(reducer, initialState);

      return (
        <StateContext.Provider value={state}>
          <DispatchContext.Provider value={dispatch}>
            {children}
          </DispatchContext.Provider>
        </StateContext.Provider>
      );
    }

    // Components only using dispatch won't re-render on state changes
    function ActionButtons() {
      const dispatch = useContext(DispatchContext)!;
      // ...
    }

custom_hooks_library:
  useLocalStorage: |
    function useLocalStorage<T>(key: string, initialValue: T) {
      const [storedValue, setStoredValue] = useState<T>(() => {
        try {
          const item = window.localStorage.getItem(key);
          return item ? JSON.parse(item) : initialValue;
        } catch {
          return initialValue;
        }
      });

      const setValue = (value: T | ((val: T) => T)) => {
        try {
          const valueToStore = value instanceof Function
            ? value(storedValue)
            : value;
          setStoredValue(valueToStore);
          window.localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {
          console.error(error);
        }
      };

      return [storedValue, setValue] as const;
    }

  useAsync: |
    interface AsyncState<T> {
      data: T | null;
      loading: boolean;
      error: Error | null;
    }

    function useAsync<T>(asyncFunction: () => Promise<T>, deps: any[] = []) {
      const [state, setState] = useState<AsyncState<T>>({
        data: null,
        loading: true,
        error: null,
      });

      useEffect(() => {
        let mounted = true;

        setState(prev => ({ ...prev, loading: true }));

        asyncFunction()
          .then(data => {
            if (mounted) setState({ data, loading: false, error: null });
          })
          .catch(error => {
            if (mounted) setState({ data: null, loading: false, error });
          });

        return () => { mounted = false; };
      }, deps);

      return state;
    }

  useToggle: |
    function useToggle(initialValue = false) {
      const [value, setValue] = useState(initialValue);

      const toggle = useCallback(() => setValue(v => !v), []);
      const setTrue = useCallback(() => setValue(true), []);
      const setFalse = useCallback(() => setValue(false), []);

      return { value, toggle, setTrue, setFalse };
    }

testing:
  pattern: |
    import { render, screen } from '@testing-library/react';
    import userEvent from '@testing-library/user-event';
    import { ThemeProvider, useTheme } from './ThemeContext';

    // Test wrapper
    function TestComponent() {
      const { theme, toggleTheme } = useTheme();
      return (
        <div>
          <span data-testid="theme">{theme}</span>
          <button onClick={toggleTheme}>Toggle</button>
        </div>
      );
    }

    describe('ThemeContext', () => {
      it('provides theme and toggle function', async () => {
        render(
          <ThemeProvider>
            <TestComponent />
          </ThemeProvider>
        );

        expect(screen.getByTestId('theme')).toHaveTextContent('light');

        await userEvent.click(screen.getByRole('button'));

        expect(screen.getByTestId('theme')).toHaveTextContent('dark');
      });
    });

when_to_use:
  context_good_for:
    - "Theme data"
    - "Current user/auth state"
    - "Localization/i18n"
    - "Feature flags"
    - "UI state (sidebar open, modal visible)"

  consider_alternatives:
    - "Complex state logic → useReducer + Context or Zustand"
    - "Server state → TanStack Query"
    - "Frequently updating state → Zustand/Jotai"
    - "Large applications → Redux Toolkit"
